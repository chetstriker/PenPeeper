import 'dart:io';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:penpeeper/repositories/vulnerability_repository.dart';
import 'package:penpeeper/services/config_service.dart';
import 'package:penpeeper/services/app_paths_service.dart';

class SearchsploitScanService {
  final VulnerabilityRepository _vulnRepo = VulnerabilityRepository();

  Future<String> runSearchsploitScan(String nmapXml) async {
    final tempPath = AppPathsService().getTempScanPath('temp_searchsploit', 'xml');
    final tempFile = File(tempPath);
    await tempFile.writeAsString(nmapXml);

    try {
      final result = await Process.run(
        (ConfigService.isLinux || ConfigService.isMacOS) ? 'searchsploit' : 'wsl.exe',
        (ConfigService.isLinux || ConfigService.isMacOS)
            ? ['--nmap', tempFile.path, '-j']
            : ['searchsploit', '--nmap', tempFile.path, '-j'],
        workingDirectory: Directory.current.path,
      ).timeout(Duration(minutes: 2));

      try {
        await tempFile.delete();
      } catch (e) {
        debugPrint('Warning: Could not delete temp file: $e');
      }

      if (result.stdout.toString().trim().isEmpty) {
        return '[]';
      }

      return result.stdout.toString();
    } catch (e) {
      try {
        await tempFile.delete();
      } catch (_) {}
      rethrow;
    }
  }

  Future<void> parseAndStoreResults(int deviceId, String jsonResult) async {
    try {
      final lines = jsonResult.split('\n');
      final jsonObjects = <String>[];
      String currentJson = '';
      int braceCount = 0;

      for (final line in lines) {
        if (line.trim().startsWith('{')) {
          if (braceCount == 0) {
            currentJson = line;
          } else {
            currentJson += '\n$line';
          }
          braceCount += line.split('{').length - 1;
          braceCount -= line.split('}').length - 1;
        } else if (braceCount > 0) {
          currentJson += '\n$line';
          braceCount += line.split('{').length - 1;
          braceCount -= line.split('}').length - 1;
        }

        if (braceCount == 0 && currentJson.isNotEmpty) {
          jsonObjects.add(currentJson);
          currentJson = '';
        }
      }

      // Collect all vulnerabilities first, then batch insert
      final vulnerabilities = <Map<String, dynamic>>[];

      for (final jsonStr in jsonObjects) {
        try {
          final data = json.decode(jsonStr) as Map<String, dynamic>;

          final exploits = data['RESULTS_EXPLOIT'] as List?;
          if (exploits != null && exploits.isNotEmpty) {
            for (final exploit in exploits) {
              if (exploit is Map<String, dynamic>) {
                final title = exploit['Title']?.toString() ?? 'Unknown Exploit';
                final edbId = exploit['EDB-ID']?.toString() ?? '';
                final url = edbId.isNotEmpty
                    ? 'https://www.exploit-db.com/exploits/$edbId'
                    : '';

                vulnerabilities.add({
                  'device_id': deviceId,
                  'type': 'SearchSploit',
                  'title': title,
                  'description': 'Exploit found in SearchSploit database (EDB-ID: $edbId)',
                  'severity': 'Low',
                  'url': url,
                });
              }
            }
          }

          final shellcodes = data['RESULTS_SHELLCODE'] as List?;
          if (shellcodes != null && shellcodes.isNotEmpty) {
            for (final shellcode in shellcodes) {
              if (shellcode is Map<String, dynamic>) {
                final title =
                    shellcode['Title']?.toString() ?? 'Unknown Shellcode';
                final edbId = shellcode['EDB-ID']?.toString() ?? '';
                final url = edbId.isNotEmpty
                    ? 'https://www.exploit-db.com/shellcodes/$edbId'
                    : '';

                vulnerabilities.add({
                  'device_id': deviceId,
                  'type': 'SearchSploit',
                  'title': title,
                  'description': 'Shellcode found in SearchSploit database (EDB-ID: $edbId)',
                  'severity': 'Low',
                  'url': url,
                });
              }
            }
          }
        } catch (e) {
          debugPrint('Failed to parse individual JSON object: $e');
        }
      }

      // Batch insert all vulnerabilities in a single transaction
      if (vulnerabilities.isNotEmpty) {
        await _vulnRepo.batchInsertVulnerabilities(vulnerabilities);
      }
    } catch (e) {
      debugPrint('Failed to parse SearchSploit results: $e');
    }
  }
}
