import 'package:penpeeper/repositories/base_repository.dart';
import 'package:penpeeper/database/connection/database_connection.dart';
import 'package:penpeeper/api_database_helper.dart';
import 'package:penpeeper/services/project_data_cache.dart';
import 'package:penpeeper/models/vulnerability_classification.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;

class VulnerabilityRepository extends BaseRepository {
  final _dbConnection = DatabaseConnection();

  Future<void> insertVulnerability(int deviceId, String type, String title, String description, String severity, String url) async {
    final db = await _dbConnection.database;
    await db.insert('vulnerabilities', {
      'device_id': deviceId,
      'type': type,
      'title': title,
      'description': description,
      'severity': severity,
      'url': url,
      'created_at': DateTime.now().toIso8601String(),
    });

    if (type == 'SearchSploit') {
      final cache = ProjectDataCache();
      cache.addDeviceToScanType('SearchSploit', deviceId);
    }
  }

  /// Batch insert vulnerabilities in a single transaction to prevent database locking
  Future<void> batchInsertVulnerabilities(List<Map<String, dynamic>> vulnerabilities) async {
    if (vulnerabilities.isEmpty) return;

    final db = await _dbConnection.database;
    final batch = db.batch();

    for (final vuln in vulnerabilities) {
      batch.insert('vulnerabilities', {
        'device_id': vuln['device_id'],
        'type': vuln['type'],
        'title': vuln['title'],
        'description': vuln['description'],
        'severity': vuln['severity'],
        'url': vuln['url'],
        'created_at': DateTime.now().toIso8601String(),
      });
    }

    await batch.commit(noResult: true);

    // Update cache after batch insert
    if (vulnerabilities.isNotEmpty && vulnerabilities.first['type'] == 'SearchSploit') {
      final cache = ProjectDataCache();
      cache.addDeviceToScanType('SearchSploit', vulnerabilities.first['device_id']);
    }
  }

  Future<List<Map<String, dynamic>>> getVulnerabilities(int deviceId, String type) async {
    final db = await _dbConnection.database;
    return await db.query('vulnerabilities',
      where: 'device_id = ? AND type = ?',
      whereArgs: [deviceId, type],
      orderBy: 'created_at DESC',
    );
  }

  Future<List<Map<String, dynamic>>> getAllVulnerabilities(int deviceId) async {
    if (kIsWeb) {
      return [];
    }
    final db = await _dbConnection.database;
    return await db.query('vulnerabilities',
      where: 'device_id = ?',
      whereArgs: [deviceId],
      orderBy: 'created_at DESC',
    );
  }

  Future<int> insertVulnerabilityClassification({
    required int projectId,
    required int deviceId,
    required int findingId,
    required String category,
    required String subcategory,
    required String description,
    required String mappedOwasp,
    required String mappedCwe,
    required String severityGuideline,
    String? scope,
  }) async {
    final finalScope = scope ?? 'NETWORK';
    if (kIsWeb) {
      return await ApiDatabaseHelper().insertVulnerabilityClassification(
        projectId: projectId,
        deviceId: deviceId,
        findingId: findingId,
        category: category,
        subcategory: subcategory,
        description: description,
        mappedOwasp: mappedOwasp,
        mappedCwe: mappedCwe,
        severityGuideline: severityGuideline,
        scope: finalScope,
      );
    }
    final db = await _dbConnection.database;
    return await db.insert('vulnerability_classifications', {
      'project_id': projectId,
      'device_id': deviceId,
      'finding_id': findingId,
      'category': category,
      'subcategory': subcategory,
      'description': description,
      'mapped_owasp': mappedOwasp,
      'mapped_cwe': mappedCwe,
      'severity_guideline': severityGuideline,
      'scope': finalScope,
      'created_at': DateTime.now().toIso8601String(),
    });
  }

  Future<List<VulnerabilityClassification>> getVulnerabilityClassifications(int findingId) async {
    if (kIsWeb) {
      final maps = await ApiDatabaseHelper().getVulnerabilityClassifications(findingId);
      return maps.map((map) => VulnerabilityClassification.fromMap(map)).toList();
    }
    final db = await _dbConnection.database;
    final maps = await db.query('vulnerability_classifications',
      where: 'finding_id = ?',
      whereArgs: [findingId],
      orderBy: 'created_at DESC',
    );
    return maps.map((map) => VulnerabilityClassification.fromMap(map)).toList();
  }

  Future<VulnerabilityClassification?> getVulnerabilityClassificationByFindingId(int findingId) async {
    if (kIsWeb) {
      final map = await ApiDatabaseHelper().getVulnerabilityClassificationByFindingId(findingId);
      return map != null ? VulnerabilityClassification.fromMap(map) : null;
    }
    final db = await _dbConnection.database;
    final results = await db.query('vulnerability_classifications',
      where: 'finding_id = ?',
      whereArgs: [findingId],
      orderBy: 'created_at DESC',
      limit: 1,
    );
    return results.isNotEmpty ? VulnerabilityClassification.fromMap(results.first) : null;
  }

  Future<Map<String, dynamic>?> getVulnerabilityClassificationByFindingIdRaw(int findingId) async {
    if (kIsWeb) {
      return await ApiDatabaseHelper().getVulnerabilityClassificationByFindingId(findingId);
    }
    final db = await _dbConnection.database;
    final results = await db.query('vulnerability_classifications',
      where: 'finding_id = ?',
      whereArgs: [findingId],
      orderBy: 'created_at DESC',
      limit: 1,
    );
    return results.isNotEmpty ? results.first : null;
  }

  Future<List<Map<String, dynamic>>> getVulnerabilityClassificationsRaw(int findingId) async {
    if (kIsWeb) {
      return await ApiDatabaseHelper().getVulnerabilityClassifications(findingId);
    }
    final db = await _dbConnection.database;
    return await db.query('vulnerability_classifications',
      where: 'finding_id = ?',
      whereArgs: [findingId],
      orderBy: 'created_at DESC',
    );
  }

  Future<void> updateVulnerabilityClassification(int id, {
    String? category,
    String? subcategory,
    String? scope,
  }) async {
    if (kIsWeb) {
      await ApiDatabaseHelper().updateVulnerabilityClassification(
        id,
        category: category,
        subcategory: subcategory,
        scope: scope,
      );
      return;
    }
    final db = await _dbConnection.database;
    final Map<String, dynamic> updates = {};
    if (category != null) updates['category'] = category;
    if (subcategory != null) updates['subcategory'] = subcategory;
    if (scope != null) updates['scope'] = scope;
    
    if (updates.isNotEmpty) {
      await db.update('vulnerability_classifications', updates,
        where: 'id = ?',
        whereArgs: [id],
      );
    }
  }

  Future<void> deleteVulnerabilityClassification(int id) async {
    if (kIsWeb) {
      await ApiDatabaseHelper().deleteVulnerabilityClassification(id);
      return;
    }
    final db = await _dbConnection.database;
    await db.delete('vulnerability_classifications',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  Future<bool> deviceHasValidVulnersCves(int deviceId) async {
    final db = await _dbConnection.database;
    
    final results = await db.rawQuery('''
      SELECT s.output
      FROM nmap_hosts h
      JOIN nmap_ports p ON h.id = p.host_id
      JOIN nmap_scripts s ON p.id = s.port_id
      JOIN nmap_cves c ON s.id = c.script_id
      WHERE h.device_id = ?
      LIMIT 1
    ''', [deviceId]);
    
    if (results.isEmpty) return false;
    
    final excludedPrefixes = [
      'cpe:/a:apache:http_server:',
      'cpe:/a:microsoft:iis:',
      'cpe:/a:nginx:nginx:',
      'cpe:/a:php:php:',
      'cpe:/a:genivia:gsoap:',
      'cpe:/a:goahead:goahead:',
      'cpe:/a:boa:boa:',
      'cpe:/a:microsoft:sql_server:',
      'cpe:/a:mysql:mysql:',
      'cpe:/a:mariadb:mariadb:',
      'cpe:/a:postgresql:postgresql',
      'cpe:/a:openssl:openssl:',
      'cpe:/a:net-snmp:net-snmp:',
    ];
    
    for (final row in results) {
      final output = ((row['output'] as String?) ?? '').trim();
      if (!excludedPrefixes.any((prefix) => output.startsWith(prefix))) {
        return true;
      }
    }
    
    return false;
  }

  Future<void> updateVulnersCacheForDevice(int deviceId) async {
    final hasVulners = await deviceHasValidVulnersCves(deviceId);
    final cache = ProjectDataCache();
    
    if (hasVulners) {
      cache.addDeviceToScanType('Vulners', deviceId);
    } else {
      cache.removeDeviceFromScanType('Vulners', deviceId);
    }
  }

  Future<void> insertWhatwebFinding(int deviceId, String finding) async {
    final db = await _dbConnection.database;
    await db.insert('whatweb_findings', {
      'device_id': deviceId,
      'finding': finding,
      'created_at': DateTime.now().toIso8601String(),
    });
    
    final cache = ProjectDataCache();
    cache.addDeviceToScanType('WhatWeb', deviceId);
  }

  Future<void> deleteWhatwebFindings(int deviceId) async {
    final db = await _dbConnection.database;
    await db.delete('whatweb_findings',
      where: 'device_id = ?',
      whereArgs: [deviceId],
    );
    
    final cache = ProjectDataCache();
    cache.removeDeviceFromScanType('WhatWeb', deviceId);
  }

  Future<List<Map<String, dynamic>>> getWhatwebFindings(int deviceId) async {
    final db = await _dbConnection.database;
    return await db.query('whatweb_findings',
      where: 'device_id = ?',
      whereArgs: [deviceId],
      orderBy: 'created_at DESC',
    );
  }

  Future<void> insertFfufFinding(int deviceId, String url, int status, int words) async {
    final db = await _dbConnection.database;
    await db.insert('ffuf_findings', {
      'device_id': deviceId,
      'url': url,
      'status': status,
      'words': words,
      'created_at': DateTime.now().toIso8601String(),
    });
    
    final cache = ProjectDataCache();
    cache.addDeviceToScanType('FFUF', deviceId);
  }

  Future<void> deleteFfufFindings(int deviceId) async {
    final db = await _dbConnection.database;
    await db.delete('ffuf_findings',
      where: 'device_id = ?',
      whereArgs: [deviceId],
    );
    
    final cache = ProjectDataCache();
    cache.removeDeviceFromScanType('FFUF', deviceId);
  }

  Future<List<Map<String, dynamic>>> getFfufFindings(int deviceId) async {
    final db = await _dbConnection.database;
    return await db.query('ffuf_findings',
      where: 'device_id = ?',
      whereArgs: [deviceId],
      orderBy: 'status ASC, url ASC',
    );
  }

  Future<void> insertSambaLdapFinding(int deviceId, String findingType, String findingValue) async {
    final db = await _dbConnection.database;
    await db.insert('samba_ldap_findings', {
      'device_id': deviceId,
      'finding_type': findingType,
      'finding_value': findingValue,
      'created_at': DateTime.now().toIso8601String(),
    });
    
    final cache = ProjectDataCache();
    cache.addDeviceToScanType('SAMBA', deviceId);
  }

  Future<List<Map<String, dynamic>>> getSambaLdapFindings(int deviceId) async {
    final db = await _dbConnection.database;
    return await db.query('samba_ldap_findings',
      where: 'device_id = ?',
      whereArgs: [deviceId],
      orderBy: 'created_at DESC',
    );
  }
}
